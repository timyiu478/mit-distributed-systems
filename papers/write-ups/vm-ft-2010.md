---
title: The Design of Practical System for Fault-Tolerance Virtual Machine
description:
tags: ["Fault-Tolerance", "Backup"]
reference: https://pdos.csail.mit.edu/6.824/papers/vm-ft.pdf
---

## Key Contributions

* Bressoud and Schneider [3] describe a prototype implementation of fault-tolerant VMs for the HP PA-RISC platform. 
* They have made some fundamental changes for **performance reasons** and investigated a number of **design alternatives**. 
    * efficient event delivery mechanism
* In addition, we have had to design and implement many additional components in the system and deal with a number of **practical issues** to build a complete system that is efficient and usable by customers running enterprise applications.

## Basic Fault-Tolerance Design

![](assets/basic_ft_design.png)

## Deterministic Replay Implementation

* Deterministic replay records the inputs of a VM and all possible non-determinism associated with the VM execution in a stream of log entries written to a log file.
* For non-deterministic operations, sufficient information is logged to allow the operation to be reproduced with the same state change and output. During replay, the event is delivered at the same point in the instruction stream.

## FT Protocol

Challenge 1: suppose a failure were to happen immediately after the primary executed the output operation and only “go live” (stop replaying and take over as the primary VM) at that point. If the backup were to go live at the point of the last log entry before the output operation, some non-deterministic event might change its execution path before it executed the output operation.

![](assets/vm-ft-failover-challenge-1.png)

Solution 1: 

1. create a special log entry at each output operation.
1. output rule: primary may not send the output to the external world, until the backup has received and acknowledged the log entry associated with the operation producing the output.

![](assets/vm-ft-protocol.png)

Note: The backup **cannot** determine if a primary crashed immediately before or after sending its last output.

## Detecting and Responding to Failure

![](assets/vm-ft-detect-and-responding-to-failure.png)


## Questions


Q. What is the failure mode the system target to deal with?

* Fail-Stop: failure be detected before the failing server causes an incorrect externally visible action


Q. What are the ways of replicating states to backup machine?

* replicate all states (CPU, Memory, I/O devices)
    * cons: need high bandwidth for transfering states from primary to backup
* Sate Machine Approach(Replicate Computation)
    * keep them in sync by letting them receiving the same inputs with same order
    * pros: need less bandwidth, ideal for deterministic state transition and the information for state transition is less than the information for memory update
    * cons: need a way to handle non-deterministic operations (e.g. reading a time of the clock, I/O Interrupt events)


Q. Why is SMR approach suitable for VM?

* VM can be considered as a state machine where all its operation are being virtualized => The hypervisor can capture all non-deterministic operations from the primary and replay them correctly to the backup.
* better physical seperation => primary and backup can run on different physical machine


Q. Whare are the challenges of replicating execution of any VM running any operating system and workload?

1. correctly capturing all the input and non-determinism necessary to ensure deterministic execution of a backup virtual machine
1. correctly applying the inputs and nondeterminism to the backup virtual machine
1. doing in a manner that does not degrade performance

Q. The paper says FT doesn't cope with multi-processor guests. Why not?

In general, the results of software running on multiple processors depends on exactly how the **instruction streams on the processors were interleaved**. For FT to ensure that the backup stays in sync with the primary, it would have to cause the interleaving to be the same on both computers. This turns out to be hard: you can't easily find out what the interleaving is on the primary, and you can't easily control it on either machine.

Q. How can 2 phrase commit help the backup to determine if a primary crashed immediately before or after sending its last output?



Q. What is "an atomic test-and-set operation on the shared storage"?

The system uses a network disk server, shared by both primary and backup (the "shared disk" in Figure 1). That network disk server has a "test-and-set service". The test-and-set service maintains a flag that is initially set to false. If the primary or backup thinks the other server is dead, and thus that it should take over by itself, it first sends a test-and-set operation to the disk server.

The primary (or backup) only takes over ("goes live") if test-and-set returns true.

The higher-level view is that, if the primary and backup lose network contact with each other, we want only one of them to go live. The danger is that, if both are up and the network has failed, both may go live and develop split brain. If only one of the primary or backup can talk to the disk server, then that server alone will go live. But what if both can talk to the disk server? Then the network disk server acts as a tie-breaker; test-and-set returns true only to the first call.

Q. How does VM FT handle network partitions? That is, is it possible that if the primary and the backup end up in different network partitions that the backup will become a primary too and the system will run with two primaries?

VM FT prevent the system will run with two primaries by using a shared disk. Both VMs can talk to the shared disk, or neither can. 
The primary (or backup) only takes over ("goes live") if test-and-set returns true.

Q. what I find most confusing about the paper?
